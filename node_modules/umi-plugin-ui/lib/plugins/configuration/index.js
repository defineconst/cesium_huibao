"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatConfigs = formatConfigs;
exports.useConfigKey = useConfigKey;
exports.default = _default;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function _assert() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

const KEYS = ['group', 'name', 'title', 'default', 'type', 'choices', 'description', 'value', 'transforms', 'link'];
const KEYS_WITH_LANG = ['title', 'description', 'link'];
const DEFAULT_GROUP_MAP = {
  basic: {
    'zh-CN': '基础配置',
    'en-US': 'Basic Configuration'
  },
  route: {
    'zh-CN': '路由配置',
    'en-US': 'Route Configuration'
  },
  deploy: {
    'zh-CN': '部署配置',
    'en-US': 'Deploy Configuration'
  },
  webpack: {
    'zh-CN': 'Webpack 配置',
    'en-US': 'Webpack Configuration'
  }
};

function getTextByLang(text, lang) {
  if (!text) return null;

  if (typeof text === 'string') {
    return text;
  } else if (lang in text) {
    return text[lang];
  } else {
    (0, _assert().default)('en-US' in text, `Invalid text ${text}, should have en-US key`);
    return text['en-US'];
  }
}

function formatConfigs(configs, opts = {}) {
  const _opts$lang = opts.lang,
        lang = _opts$lang === void 0 ? 'en-US' : _opts$lang,
        _opts$groupMap = opts.groupMap,
        groupMap = _opts$groupMap === void 0 ? DEFAULT_GROUP_MAP : _opts$groupMap;
  return configs.reduce((memo, config) => {
    (config.configs || [config]).forEach(config => {
      if (config.type) {
        memo.push(Object.keys(config).reduce((memo, key) => {
          if (KEYS.includes(key)) {
            if (key === 'group') {
              memo[key] = groupMap[config[key]] ? getTextByLang(groupMap[config[key]], lang) : config[key];
            } else if (KEYS_WITH_LANG.includes(key)) {
              memo[key] = getTextByLang(config[key], lang);
            } else {
              memo[key] = config[key];
            }
          }

          if (!memo.group) {
            memo.group = lang === 'zh-CN' ? '未分组' : 'Ungrouped';
          }

          return memo;
        }, {}));
      }
    });
    return memo;
  }, []);
}

function useConfigKey(config, key) {
  const keys = key.split('.');
  let i = 0;

  while (typeof config === 'object' && keys[i] in config) {
    const newConfig = config[keys[i]];

    if (i === keys.length - 1) {
      return [true, newConfig];
    }

    config = newConfig;
    i += 1;
  }

  return [false];
}

function _default(api) {
  function getConfig(lang) {
    const userConfig = api.service.userConfig;
    const config = userConfig.getConfig({
      force: true
    });
    return formatConfigs(userConfig.plugins, {
      lang,
      groupMap: api.applyPlugins('modifyUIConfigurationGroupMap', {
        initialValue: DEFAULT_GROUP_MAP
      })
    }).map(p => {
      const _useConfigKey = useConfigKey(config, p.name),
            _useConfigKey2 = _slicedToArray(_useConfigKey, 2),
            haveKey = _useConfigKey2[0],
            value = _useConfigKey2[1];

      if (haveKey) {
        p.value = value;

        if (p.transforms) {
          p.value = p.transforms[0](p.value);
        }
      }

      if (!p.link) {
        const baseUrl = lang === 'zh-CN' ? 'https://umijs.org/zh/config/' : 'https://umijs.org/config/';
        p.link = `${baseUrl}#${p.name.toLowerCase().replace(/\./g, '-')}`;
      }

      return p;
    });
  }

  function parseString(str) {
    if (str.startsWith('{') || str.startsWith('[') || str === 'true' || str === 'false') {
      return JSON.parse(str);
    } else {
      return str;
    }
  } // TODO: 支持子项的 validate


  function validateConfig(config) {
    let errors = [];
    const userConfig = api.service.userConfig;
    userConfig.plugins.forEach(p => {
      if (p.name in config) {
        try {
          if (p.transforms) {
            config[p.name] = JSON.stringify(p.transforms[1](config[p.name]));
          }

          if (p.validate) {
            p.validate(parseString(config[p.name]));
          }
        } catch (e) {
          errors.push({
            name: p.name,
            errors: [e.message]
          });
        }
      }
    });

    if (errors.length) {
      const e = new Error('Config validate failed');
      e.errors = errors;
      throw e;
    }
  }

  api.addUIPlugin(require.resolve('../../../src/plugins/configuration/dist/ui.umd'));
  api.onUISocket(({
    action,
    failure,
    success
  }) => {
    const type = action.type,
          payload = action.payload,
          lang = action.lang;

    switch (type) {
      case 'org.umi.config.list':
        success({
          data: getConfig(lang)
        });
        break;

      case 'org.umi.config.edit':
        let config = payload.key;

        if (typeof payload.key === 'string') {
          config = {
            [payload.key]: payload.value
          };
        }

        try {
          validateConfig(config);
          api.service.runCommand('config', {
            _: ['set', config]
          });
          success();
        } catch (e) {
          failure({
            message: e.message,
            errors: e.errors
          });
        }

        break;

      default:
        break;
    }
  });
}